// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel FillVertexBuffer
#pragma kernel FillTriangleBuffer
#pragma kernel SimulateWaves

// Parameters for setting up the vertex and triangle buffer
RWStructuredBuffer<float3> vertexBuffer;
RWStructuredBuffer<int> triangleBuffer;
float vertexSpread; 
int oceanWidthVertexCount;
int oceanLengthVertexCount;

// Parameters for simulating waves
float time;

[numthreads(32,32,1)]
void FillVertexBuffer (uint3 id : SV_DispatchThreadID) {
    if(id.x >= (uint)oceanWidthVertexCount || id.y > (uint)oceanLengthVertexCount) {
        return;
    }

    int index = id.y * oceanWidthVertexCount + id.x;
    vertexBuffer[index] = float3(id.x * vertexSpread, 0, id.y * vertexSpread);
}

[numthreads(32,32,1)]
void FillTriangleBuffer (uint3 id : SV_DispatchThreadID) {
    if(id.x >= ((uint)oceanWidthVertexCount - 1) || id.y >= ((uint)oceanLengthVertexCount - 1)) {
        return;
    }
    
    int baseIndex = (id.y * (oceanWidthVertexCount - 1) + id.x) * 6;

    int bottomLeft = id.y * oceanWidthVertexCount + id.x;
    int topLeft = bottomLeft + oceanWidthVertexCount;
    int topRight = topLeft + 1;
    int bottomRight = bottomLeft + 1;

    // Top-left, Top-right, Bottom-left
    triangleBuffer[baseIndex] = bottomLeft;
    triangleBuffer[baseIndex + 1] = topLeft;
    triangleBuffer[baseIndex + 2] = topRight;

    // Top-right, Bottom-right, Bottom-left
    triangleBuffer[baseIndex + 3] = topRight;
    triangleBuffer[baseIndex + 4] = bottomRight;
    triangleBuffer[baseIndex + 5] = bottomLeft;
}

[numthreads(32,32,1)]
void SimulateWaves (uint3 id : SV_DispatchThreadID) {
    if (id.x >= (uint)oceanWidthVertexCount || id.y >= (uint)oceanLengthVertexCount) {
        return;
    }

    // Calculate the index in the vertex buffer
    int index = id.y * oceanWidthVertexCount + id.x;
    // Get the current position of the vertex
    float3 position = vertexBuffer[index];

    // Calculate wave displacement using a sine function
    float waveHeight = 1 * sin(1 * (position.x + position.z - 1 * time));

    // Update the vertex position with the new wave height
    position.y = waveHeight;

    // Store the updated position back in the vertex buffer
    vertexBuffer[index] = position;

}

