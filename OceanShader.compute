//https://discussions.unity.com/t/how-to-acheive-flat-specular-highlights/853360

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel FillVertexBuffer
#pragma kernel FillTriangleBuffer
#pragma kernel SimulateWaves
#pragma kernel CalculateNormals

// Parameters for setting up the vertices and triangles
RWStructuredBuffer<float3> vertexBuffer;
RWStructuredBuffer<int> triangleBuffer;
float3 oceanStartPosition;
int numberOfVerticesPerSide;
float oceanWidth;
float oceanLength;

// Parameters for simulating waves
RWStructuredBuffer<float3> normalBuffer;
Texture2D noiseTexture;
SamplerState samplerState;
float waveAmplitude;
float time;
float2 windDirection;
float windStrength;


[numthreads(32,32,1)]
void FillVertexBuffer (uint3 id : SV_DispatchThreadID) {
    if(id.x >= (uint)numberOfVerticesPerSide || id.y > (uint)numberOfVerticesPerSide) {
        return;
    }

    int index = id.y * numberOfVerticesPerSide + id.x;
    float xStep = oceanWidth / numberOfVerticesPerSide;
    float zStep = oceanLength / numberOfVerticesPerSide;
    vertexBuffer[index] = float3(oceanStartPosition.x + id.x * xStep, oceanStartPosition.y, oceanStartPosition.z + id.y * zStep);
}

[numthreads(32,32,1)]
void FillTriangleBuffer (uint3 id : SV_DispatchThreadID) {
    if(id.x >= ((uint)numberOfVerticesPerSide - 1) || id.y >= ((uint)numberOfVerticesPerSide - 1)) {
        return;
    }
    
    int baseIndex = (id.y * (numberOfVerticesPerSide - 1) + id.x) * 6;

    int bottomLeft = id.y * numberOfVerticesPerSide + id.x;
    int topLeft = bottomLeft + numberOfVerticesPerSide;
    int topRight = topLeft + 1;
    int bottomRight = bottomLeft + 1;

    // Top-left, Top-right, Bottom-left
    triangleBuffer[baseIndex] = bottomLeft;
    triangleBuffer[baseIndex + 1] = topLeft;
    triangleBuffer[baseIndex + 2] = topRight;

    // Top-right, Bottom-right, Bottom-left
    triangleBuffer[baseIndex + 3] = topRight;
    triangleBuffer[baseIndex + 4] = bottomRight;
    triangleBuffer[baseIndex + 5] = bottomLeft;
}

float OceanWaveHeight(float4 noise, float time) {
    // Animate UVs independently for each layer
    float layer1 = noise.r * 0.6; // Large swells
    float layer2 = noise.g * 0.3; // Medium waves
    float layer3 = noise.b * 0.2; // Choppy waves
    float layer4 = noise.a * 0.1; // Fine ripples
    float baseOffset = (0.6 + 0.3 + 0.2 + 0.1) * 0.5;
    // Combine layers with weights
    return (layer1 + layer2 + layer3 + layer4) / 1.2 - 0.5;
}

[numthreads(32,32,1)]
void SimulateWaves (uint3 id : SV_DispatchThreadID) {
    if (id.x >= (uint)numberOfVerticesPerSide || id.y >= (uint)numberOfVerticesPerSide) {
        return;
    }

    // Calculate the index in the vertex buffer
    int index = id.y * numberOfVerticesPerSide + id.x;
    // Get the current position of the vertex
    float3 position = vertexBuffer[index];

    // Update the vertex position with the new wave height
    float2 uv = float2(id.x / (float)numberOfVerticesPerSide, id.y / (float)numberOfVerticesPerSide);

    // Scroll the UVs based on time
    float2 windOffset = windDirection * time * windStrength;
    float2 movingUV = uv + windOffset;

    // Wrap the UVs to [0, 1] using frac
    uv = frac(movingUV);
    
    uint width, height;
    noiseTexture.GetDimensions(width, height); // Get the texture dimensions
    uint2 texCoord = uint2(uv * uint2(width, height)); // Map the UV to integer texture coordinates
    float4 noise = noiseTexture.Load(int3(texCoord, 0)); 

    float waveHeight = OceanWaveHeight(noise, time);
    waveHeight  = 1 * sin(1 * (position.x + position.z - 1 * time));

    position.y = waveHeight * waveAmplitude;
    vertexBuffer[index] = position;
}

[numthreads(32,32,1)]
void CalculateNormals (uint3 id : SV_DispatchThreadID) {
    if (id.x >= (uint)(numberOfVerticesPerSide - 1) || id.y >= (uint)(numberOfVerticesPerSide - 1)) {
        return;
    }
    
    // Calculate the base index for this quad's two triangles
    int baseIndex = (id.y * (numberOfVerticesPerSide - 1) + id.x) * 6;

    // First triangle (bottom-left, top-left, top-right)
    int index0 = triangleBuffer[baseIndex];
    int index1 = triangleBuffer[baseIndex + 1];
    int index2 = triangleBuffer[baseIndex + 2];

    // Get the positions of the vertices
    float3 p0 = vertexBuffer[index0];
    float3 p1 = vertexBuffer[index1];
    float3 p2 = vertexBuffer[index2];

    // Calculate the normal
    float3 normal1 = normalize(cross(p2 - p0, p1 - p0));

    // Assign the normal to the vertices of the first triangle
    normalBuffer[baseIndex] = normal1;
    normalBuffer[baseIndex + 1] = normal1;
    normalBuffer[baseIndex + 2] = normal1;

    // Second triangle (top-right, bottom-right, bottom-left)
    index0 = triangleBuffer[baseIndex + 3];
    index1 = triangleBuffer[baseIndex + 4];
    index2 = triangleBuffer[baseIndex + 5];

    // Get the positions of the vertices
    p0 = vertexBuffer[index0];
    p1 = vertexBuffer[index1];
    p2 = vertexBuffer[index2];

    // Calculate the normal
    float3 normal2 = normalize(cross(p2 - p0, p1 - p0));

    // Assign the normal to the vertices of the second triangle
    normalBuffer[baseIndex + 3] = normal2;
    normalBuffer[baseIndex + 4] = normal2;
    normalBuffer[baseIndex + 5] = normal2;
}



